### 2.4.1. 元組賦值

元組賦值是另一種形式的賦值語句, 允許同時更新多個變量的值. 在賦值之前, 賦值語句右邊的所有表達式將會先進行求值, 然後再統一更新左邊變量的值. 這對於處理有些同時齣現在元組賦值語句左右兩邊的變量很有幫助, 例如我們可以這樣交換兩個變量的值:

```Go
x, y = y, x

a[i], a[j] = a[j], a[i]
```

或者是計算兩個整數值的的最大公約數(GCD):

```Go
func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}
```

或者是計算斐波納契數列(Fibonacci)的第N個數:

```Go
func fib(n int) int {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		x, y = y, x+y
	}
	return x
}
```

元組賦值也可以使一繫列瑣碎賦值更緊湊(譯註: 特別是在for循環的初始化部分),

```Go
i, j, k = 2, 3, 5
```

但如果表達式太復雜的話, 應該儘量避免元組賦值; 因爲一個個單獨的賦值語句的可讀性會更好.

某些表達式會產生多個值, 比如調用一個有多個返迴值的函數. 
當這樣一個函數調用齣現在元組賦值右邊的表達式中時(譯註: 右邊不能再有其他表達式), 左邊變量的數目必鬚和右邊一緻.

```Go
f, err = os.Open("foo.txt") // function call returns two values
```

通常, 這類函數會用額外的返迴值表達某種錯誤類型, 例如 os.Open 是返迴一個 error 類型的錯誤, 還有一些是返迴佈爾值, 通常被稱爲ok. 在稍後我們看到的三個操作都是類似的行爲.  如果 字典査找(§4.3), 類型斷言(§7.10), 或 通道接收(§8.4.2) 齣現在賦值語句的右邊, 它們都將產生兩個結果, 有一個額外的佈爾結果表示操作是否成功:

```Go
v, ok = m[key]             // map lookup
v, ok = x.(T)              // type assertion
v, ok = <-ch               // channel receive
```

和變量的聲明一樣, 我們可以用下劃綫空白標識符 `_` 來丟棄不需要的值.

```Go
_, err = io.Copy(dst, src) // 丟棄字節數
_, ok = x.(T)              // 隻檢測類型, 忽略具體值
```

