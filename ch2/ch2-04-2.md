### 2.4.2. 可賦值性

賦值語句是顯示的賦值形式, 但是程序中還有很多地方會發送隱式的賦值行爲: 函數調用將隱式地將調用參數的值賦值給函數的參數變量, 一個返迴語句將隱式地將返迴操作的值賦值給結果變量, 一個復合類型的字面量(§4.2)也會產生賦值行爲. 例如下面的語句:

```Go
medals := []string{"gold", "silver", "bronze"} 
```

隱式地對切片的每個元素進行賦值操作, 類似這樣寫的行爲:

```Go
medals[0] = "gold" 
medals[1] = "silver" 
medals[2] = "bronze" 
```

字典和管道的元素, 雖然不是普通的變量, 但是也有類似的隱式賦值行爲.

不管是隱式還是顯示地賦值, 在賦值語句坐標的變量和右邊最終的求到的值必鬚有相同的數據類型. 更直白地說, 隻有右邊的值對於左邊的變量是可賦值的, 賦值語句纔是允許的.

可賦值性的規則對於不同類型有不同要求, 對每個新類型有關的地方我們會專門解釋.
對於目前我們已經討論過的類型, 它的規則是簡單的: 類型必鬚完全匹配, nil 可以賦值給任何指鍼或引用類型的變量. 常量(§3.6)有更靈活的規則, 這樣可以避免不必要的顯示類型轉換.

對於兩個值是否可以用 `==` 或 `!=` 進行相等比較的能力也和可賦值能力有關繫:
對於任何的比較, 第一個操作必鬚是可用於第二個操作類型的變量的賦值的, 反之依然.
和前面一樣, 我們會對每個新類型比較有關的地方會做專門解釋.


