## 3.1. 整型

Go语言的数值类型包括几种不同大小的整形数, 浮点数, 和复数. 每种数值类型都决定了对应的大小范围和是否有正负符号. 让我们先从整形数类型开始介绍.

Go同时提供了有符号和无符号的整数运算. 这里有四种int8, int16, int32 和 int64截然不同大小的有符号整形数类型, 分别对应 8, 16, 32, 64 bit 大小的有符号整形数, 与此对应的是 uint8, uint16, uint32, 和 uint64 四种无符号整形数类型.

这里还有两种对应特定平台最天然或最有效率的大小有符号和无符号整数int和uint; 其中int是应用最广泛的数值类型. 这两种类型都有同样的大小, 32 或 64 bit, 但是我们不能对此做任何的假设; 因为不同的编译器在相同的硬件平台上可能产生不同的大小.

字符rune类型是和int32等价的类型, 通常用于表示一个Unicode码点. 这两个名称可以互换使用. 同样byte也是uint8类型的等价类型, byte类型用于强调数值是一个原始的数据而不是一个小的整数.

最好, 还有一个无符号的整数类型 uintptr, 没有指定具体的bit大小但是足以容纳指针. uintptr 类型只有在底层编程是才需要, 特别是Go语言和C函数库或操作系统相交互的地方. 我们将在第十三章的 unsafe 包相关部分看到类似的例子.

不管它们的大小, int, uint, 和 uintptr 是不同类型大小的兄弟类型. 其中 int 和 int32 也是不同的类型, 即使int的大小也是32bit, 在需要将int当作int32类型的地方需要一个显式的类型转换, 反之亦然.

有符号数采用2的补码形式表示, 也就是最高位用作符号位, 一个nbit的有符号数的值域是 `-2^(n-1)` 到 `(2^(n-1)) - 1`. 无符号整数的所有bit位都用于表示非负数, 值域是 0 到 `(2^n) - 1`. 例如, int8 的值域是 -128 到 127, 而 uint8 的值域是 0 到 255.

下面是Go中关于算术, 逻辑和比较的二元运算符按照先级递减的顺序的列表:

```
*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||
```

二元运算符有五种优先级. 在同一优先级, 使用左优先结合律, 使用括号可以明确优先顺序, 括号也可以用于提升优先级, 例如 `mask & (1 << 28)`.

对于上表中前两行的运算符, 例如 + 有一个相应的赋值结合运算符 +=, 可以用于简化赋值语句.

整数的算术运算符 +, -, *, 和 / 可以适用与整数, 浮点数和复数, 但是取模运算符 % 仅用于整数. 不同编程语言间, % 取模运算的行为并不相同. 在Go语言中, % 取模运算符的符号和被取模数的符号总是一致的, 因此 `-5%3` 和 `-5%-3` 结果都是 -2.除法运算符 `/` 的行为依赖于操作数是否为整数, 因此 `5.0/4.0` 的结果是 1.25, 但是 5/4 的结果是 1, 因此整数除法会向着0方向截断余数.


如果一个算术运算的结果, 不管是有符号或者是无符号的, 如果需要更多的bit位才能表示, 就说明是溢出了. 超出的高位的bit位部分将被丢弃. 如果原始的数值是有符号类型, 那么最终结果可能是负的, 如果最左边的bit为是1的话, 例如int8的例子:

```Go
var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"

var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 -128 1"
```

两个相同的整数类型可以使用下面的二元比较运算符进行比较; 比较表达式的结果是布尔类型.

```
==    equal to
!=    not equal to
<     less than
<=    less than or equal to
>     greater than
>=    greater than or equal to
```

事实上, 布尔型, 数字类型 和 字符串 等基本类型都是可比较的, 也就是说两个相同类型的值可以用 == 和 != 进行比较. 此外, 整数, 浮点数和字符串可以根据比较结果排序. 许多其他类型的值是不可比较, 因此也就是不可排序的. 对于我们遇到的每种类型, 我们需要保证规则是类似的.

这里是一元的加法和减法运算符:

```
+      一元加法 (无效果)
-      负数
```

对于整数, +x 是 0+x 的简写, -x 是 0-x 的简写; 对于浮点数和复数, +x 就是 x, -x 则是 x 的负数.

Go语言还提供了以下的bit位操作运算符, 前面4个操作运算符并不区分是有符号还是无符号数:

```
&      位运算 AND
|      位运算 OR
^      位运算 XOR
&^     位清空 (AND NOT)
<<     左移
>>     右移
```

位操作运算符 `^` 作为二元运算符时是按位异或(XOR), 当用作一元运算符时表示按位取反; 也就是说, 它返回一个每个bit位都取反的数. 位操作运算符 `&^` 用于按位置零(AND NOT): 表达式 `z = x &^ y` 结果z的bit位1, 如果对应y中bit位为1, 否则对应的bit位等于x相应的bit位的值.


TODO
