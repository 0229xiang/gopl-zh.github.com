## 3.4. 佈爾型


一個佈爾類型的值隻有兩種 true 和 false. if 和 for 語句的條件部分都是佈爾類型的值, 並且 == 和 < 等比較操作也會產生佈爾型的值. 一元操作符 `!` 對應邏輯非操作, 因此 `!true` 的值爲 `false`, 也可以說是 `(!true==false)==true`, 雖然表達方式不一樣, 不過我們一般會採用簡潔的佈爾表達式, 就像用 x 來表示 `x==true`.

佈爾值可以和 && (AND) 和 || (OR) 操作符結合, 並且可能會有短路行爲: 如果運算符左邊值已經可以確定整個佈爾表達式的值, 那麽運算符右邊的值將不在被評估, 因此下面的表達式總是安全的:

```Go
s != "" && s[0] == 'x'
```

其中 s[0] 應用於空字符串會導緻 panic 異常.

因爲 `&&` 的優先級比 `||` 高 (助記: `&&` 對應邏輯乘法, `||` 對應邏輯加法, 乘法比加法優先級要高), 下面形式的佈爾表達式是不需要加小括弧的:

```Go
if 'a' <= c && c <= 'z' ||
	'A' <= c && c <= 'Z' ||
	'0' <= c && c <= '9' {
	// ...ASCII letter or digit...
}
```

佈爾值並不會隱式轉換爲數字值0或1, 反之亦然. 必鬚使用一個顯式的if語句輔助轉換:

```Go
i := 0
if b {
	i = 1
}
```

如果需要經常做類似的轉換, 包裝成一個函數會更方便:

```Go
// btoi returns 1 if b is true and 0 if false.
func btoi(b bool) int {
	if b {
		return 1
	}
	return 0
}
```

數字到佈爾型的逆轉換則非常簡單, 不過爲了保持對稱, 我們也可以包裝一個函數:

```Go
// itob reports whether i is non-zero.
func itob(i int) bool { return i != 0 }
```



