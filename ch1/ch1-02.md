## 1.2. 命令行參數

大多數的程序都是處理輸入，産生輸出；這也正是“計算”的定義。但是, 程序如何獲取要处理的輸入数据呢？一些程序生成自己的數據，但通常情況下，輸入來自於程序外部：文件、網絡連接、其它程序的輸出、敲鍵盤的用户、命令行參數或其它類似輸入源。下面幾個例子會討論其中几个輸入源，首先是命令行參數。

`os`包以跨平台的方式，提供了一些與操作繫統交互的函數和變量。程序的命令行參數可从os包的Args變量获取；os包外部使用os.Args访问該變量。

os.Args變量是一個字符串（string）的*切片*（slice）（譯註：slice和Python語言中的切片類似，是一個簡版的動態數組），切片是Go語言的基礎概念，稍后会详细介绍。現在先把切片s当作数组元素序列, 序列的成长度动态变化, 用`s[i]`访问单个元素，用`s[m:n]`獲取子序列(譯註：和python里的語法差不多)。序列的元素数目为len(s)。和大多數編程語言類似，区间索引时，Go言里也采用左閉右開形式, 即，区间包括第一个索引元素，不包括最後一个, 因为这样可以簡化邏輯。（譯註：比如a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3]，不包含最後一個元素）。比如s[m:n]這個切片，0 ≤ m ≤ n ≤ len(s)，包含n-m個元素。

os.Args的第一個元素，os.Args[0], 是命令本身的名字；其它的元素則是程序启动时傳給它的參數。s[m:n]形式的切片表達式，产生从第m个元素到第n-1個元素的切片，下個例子用到的元素包含在os.Args[1:len(os.Args)]切片中。如果省略切片表达式的m或n，会默认传入0或len(s)，因此前面的切片可以简写成os.Args[1:]。

下面是Unix里echo命令的一份實現，echo把它的命令行參數打印成一行。程序导入了兩個包，用括號把它们括起来写成列表形式, 而没有分开写成独立的`import`声明。两种形式都合法，列表形式习惯上用得多。包導入順序併不重要；gofmt工具格式化時按照字母順序对包名排序。（示例有多个版本时，我们会对示例编号, 这样可以明确当前正在讨论的是哪个。）

<u><i>gopl.io/ch1/echo1</i></u>
```go
// Echo1 prints its command-line arguments.
package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
```

註釋语句以`//`开头。对于程序员来说，//之后到行末之间所有的内容都是註釋，被編譯器忽略。按照慣例，我们在每个包的包声明前添加注释；對於`main package`，註釋包含一句或几句话，从整体角度对程序做个描述。

var声明定义了兩個string类型的變量s和sep。變量会在聲明时直接初始化。如果变量沒有顯式初始化，则会被隐式地賦予其類型的*零值*（zero value），數值類型是0，字符串類型是空字符串""。這個例子里，声明把s和sep隱式地初始化成空字符串。第2章再来詳細地講解變量和聲明。

對數值類型，Go語言提供了常規的數值和邏輯運算符。而對string類型，`+`运算符连接字符串（譯註：和C++或者js是一樣的）。所以表達式：

```go
sep + os.Args[i]
```

表示連接字符串sep和os.Args。程序中使用的语句：

```go
s += sep + os.Args[i]
```

是一条*赋值语句*, 將s的旧值跟sep與os.Args[i]連接后賦值回s，等价于：

```go
s = s + sep + os.Args[i]
```

運算符`+=`是賦值運算符（assignment operator），每種數值运算符或邏輯運算符，如`+`或`*`，都有對應的賦值運算符。

echo程序可以每循環一次輸出一個參數，這个版本却是不斷地把新文本追加到末尾来构造字符串。字符串s开始为空，即值为""，每次循環會添加一些文本；第一次迭代之後，还会再插入一個空格，因此循环结束时每个参数中間都有一個空格。這是一種二次加工（quadratic process），当參數數量龐大时，开销很大，但是对于echo，这种情形不大可能出现。本章会介紹echo的若干改進版，下一章解决低效问题。

循环索引变量i在for循环的第一部分中定义。符號`:=`是短变量声明（short variable declaration）的一部分, 这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。下一章有这方面更多説明。

自增语句`i++`给`i`加1；這和`i += 1`以及`i = i + 1`都是等價的。對應的還有`i--`給`i`減1。它们是語句，而不像C繫的其它語言那样是表達式。所以`j = i++`非法，而且++和--都隻能放在變量名後面，因此`--i`也非法。

Go語言隻有for循環这一種循環语句。for循環有多种形式，其中一种如下所示：

```go
for initialization; condition; post {
	// zero or more statements
}
```

for循環三个部分不需括號包围。大括号强制要求, 左大括號必须和*post*语句在同一行。

initialization部分是可選的，如果你寫了這部分的話，在for循環之前這部分的邏輯會被執行。initalization部分必須是一個簡單的語句，具體可以是一個簡短的變量聲明，一個賦值語句，或是一個函數調用。condition部分必須是一個結果爲boolean值的表達式，在每次循環之前，語言都會檢査當前是否滿足這個條件，若不滿足的話便會結束循環；post部分的語句則是在每次循環迭代結束之後被執行，之後conditon部分會在下一次執行前再次進行判斷，依此往複。當condition條件里的判斷結果變爲false之後，循環卽結束。

上面提到是for循環里的三個部分(initialization/condition/post)都是可以被省略的，如果你把initialization和post部分都省略的話，那麽連中間隔離他們的分號也是可以被省略的，比如下面這種for循環，和傳統的while循環效果完全一致：

```go
// a traditional "while" loop
for condition {
	// ...
}
```

當然了，如果你連唯一的條件都省了，那麽for循環就會變成一個無限循環，像下面這樣：

```go
// a traditional infinite loop
for {
	// ...
}
```

在無限循環中，你還是可以靠break或者return語句來終止掉循環。

如果你的遍歷對象是string或者slice類型值的話，還有另外一種循環的寫法，我們來看看另一個版本的echo：

<u><i>gopl.io/ch1/echo2</i></u>
```go
// Echo2 prints its command-line arguments.
package main

import (
	"fmt"
)

func main() {
	s, sep := "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
}
```

每一次循環迭代，range都會返迴一對兒結果；當前迭代的下標以及在該下標處的元素的值。這個例子不需要這個下標，但是因爲range函數要求我們必須同時處理下標和元素兩個返迴值。這種時候可以在聲明一個接收下標的臨時變量來解決這個問題，但Go語言又不允許隻聲明變量而在後續代碼里不使用，如果你這樣做了編譯器會返迴一個編譯錯誤。

Go語言中這種情況的解決方法是用空白標識符，對，就是代碼里那個下劃線_。空白標識符可以在任何你需要接收自己不想處理的值時使用。這里使用它來忽略掉range返迴的那個沒什麽用的下標值。大多數的Go程序員都會像上面這樣來寫類似的os.Args遍歷，由於遍歷os.Args的下標索引是隱式自動生成的，這里也併不需要關心。

上面這個版本將s和sep的聲明和初始化都放到了一起，但是我們可以等價地將聲明和賦值分開來寫，下面這些寫法都是等價的：

```go
s := ""
var s string
var s = ""
var s string = ""
```

那麽這些等價的形式應該怎麽做選擇呢？這里提供一些建議：第一種形式，隻能用在一個函數內部，而package級别的變量不應該這麽做。第二種形式依賴於string類型的內部初始化機製，被初始化爲空字符串。第三種形式使用得很少，除非同時聲明多個變量。第四種形式會顯式地標明變量的類型，在多變量同時聲明時可以用到。實踐中你應該隻使用上面的前兩種形式，顯式地指定變量的類型，讓編譯器自己去初始化其值，或者直接用隱式初始化，表明初始值怎麽樣併不重要。

像上面提到的，每次循環迭代中字符串s都會得到一個新內容。+=語句會分配一個新的字符串，併將老字符串連接起來的值賦予給它。而目標字符串的舊的字面值在得到新值以後就失去了用處，這些臨時值會被Go語言的垃圾收集器榦掉。

如果不斷連接的字符串數量衆多，那麽上面這種操作就是成本非常高的操作。更簡單併且有效的一種方式是使用strings包提供的Join函數，像下面這樣：

<u><i>gopl.io/ch1/echo3</i></u>
```go
func main() {
	fmt.Println(strings.Join(os.Args[1:], " "))
}
```

最後，如果我們對輸出的格式也不是很關心，隻是想簡單地輸出值得的話，還可以像下面這麽寫，Println函數會爲我們自動格式化輸出。

```go
fmt.Println(os.Args[1:])
```

這個輸出結果和前面的strings.Join得到的結果很相似，隻是輸出被放到了一個方括號里，對slice類型調用Println函數都會被打印成這種形式的結果。

**練習 1.1：** 脩改echo程序，使其能夠打印os.Args[0]。

**練習 1.2：** 脩改echo程序，使其打印value和index，每個value和index顯示一行。

**練習 1.3：** 上手實踐前面提到的strings.Join和直接Println，併觀察輸出結果的區别。
